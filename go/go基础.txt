1) 时间戳转时间字符串 (int64 —>  string)
        timeUnix:=time.Now().Unix()   //已知的时间戳

        formatTimeStr:=time.Unix(timeUnix,0).Format("2006-01-02 15:04:05")

        fmt.Println(formatTimeStr)   //打印结果：2017-04-11 13:30:39
   2) 时间字符串转时间(string  —>  Time)

      formatTimeStr=”2017-04-11 13:33:37”

      formatTime,err:=time.Parse("2006-01-02 15:04:05",formatTimeStr)

     if err==nil{

         fmt.Println(formatTime) //打印结果：2017-04-11 13:33:37 +0000 UTC

      }
   3) 时间字符串转时间戳 (string —>  int64)

          比上面多一步，formatTime.Unix()即可


rune(int32的别称)

int8

int16

int32

int64

byte(uint8的别称)

uint8

unit16

uint32

uint64

注意：这些类型的变量之间不允许互相赋值或操作

string转成int： 
int, err := strconv.Atoi(string)
string转成int64： 
int64, err := strconv.ParseInt(string, 10, 64)
int转成string： 
string := strconv.Itoa(int)
int64转成string： 
string := strconv.FormatInt(int64,10)


channl的发送和接收
data := <- a // read from channel a  
a <- data // write to channel a

内建函数：两个的区别
var p *[]int = new([]int)      初始化一个指针
var v []int = make([]int, 10)  初始化一个数据结构以及值


go get +  
-d 只下载不安装
-f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用
-fix 在获取源码之后先运行fix，然后再去做其他的事情
-t 同时也下载需要为运行测试所需要的包
-u 强制使用网络去更新包和它的依赖包
-v 显示执行的命令


打印格式：
%v  值的默认格式。当打印结构体时，“加号”标记（%+v）会添加字段名
%#v　相应值的Go语法表示
%T  相应值的类型的Go语法表示
%%  字面上的百分号，并非值的占位符　
s := new(Sample)
    s.a = 1
    s.str = "hello"
    fmt.Printf("%v\n", *s)　//{1 hello}
    fmt.Printf("%+v\n", *s) //  {a:1 str:hello}
    fmt.Printf("%#v\n", *s) // main.Sample{a:1, str:"hello"}
    fmt.Printf("%T\n", *s)   //  main.Sample
    fmt.Printf("%%\n", s.a) //  %  %!(EXTRA int=1) 






